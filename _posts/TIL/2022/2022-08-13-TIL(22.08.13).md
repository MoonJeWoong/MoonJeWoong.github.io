---
title:  "TIL(22.08.13)"
excerpt: "Today I Learned!"

categories:
  - TIL_2022
tags:
  - [TIL_2022, Dynamic Programming]

last_modified_at: 2022-08-14 00:01:46

toc: true
toc_label: Index
---

# 코테 - Dynamic Programming
## 문제
두 개의 문자열이 주어질 때 한 문자열을 다른 문자열로 변환하는 작업을 진행하는데 연산을 최소한으로 해서 문자열 변환을 완료하고자 한다. 이 때 사용하는 연산은 삽입, 삭제, 교체 3가지만 이용한다. 예를 들어 sunday를 saturday로 바꾸는데 필요한 최소 연산 수는 3번이다.
이 경우 최소한의 연산 수를 구하시오.

## 풀이
![](/assets/images/KakaoTalk_20220814_001537318.jpg)
2차원의 DP 테이블을 사용한다. 행에는 첫번째 문자열을, 열에는 두번째 문자열을 기준으로 DP테이블의 행과 열의 길이를 정한다. 그 뒤 초기 값을 세팅하는데 첫 번째 행은 0 ~ n-1까지 차례대로 값을 초기화해주고 첫 번째 열 또한 0 ~ m-1 까지 차례대로 초기화 해준다. 그 뒤 점화식에 따라 행렬의 값들을 채워나가면 된다. dp[i][j]의 의미는 str1[0:i+1]에 해당하는 문자열이 str2[0:j+1]에 해당하는 문자열이 되는데 필요한 최소한의 연산 수라고 생각하면 된다.

~~~
if (str1[i] == str2[j]):
dp[i][j] = dp[i-1][j-1]

else:
dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])
~~~

여기에서 dp[i][j-1]은 삽입, dp[i-1][j]는 삭제, dp[i-1][j-1]은 교체 연산이다. 이걸 딱 이렇게만 두고 보면 이해하기가 힘든데 하나씩 단계를 밟아보면 직관적으로 이해할 수 있다.

추가연산의 예를 들면 dp[1][2]를 채우기 위한 연산이 추가연산이다. 이 때 dp[1][1] 값의 직관적 의미는 's'문자열이 's'가 되기까지 필요한 최소한의 연산 수이다. 여기서 dp[1][2]의 직관적 의미는 's' 문자열이 'sa'가 되기 위한 최소한의 연산이므로 's'문자열이 's'문자열이 되기위한 최소한의 연산 수에 'a'를 추가하는 추가연산 한번만 더해주면 원하는 값을 구할 수 있다.

이와 마찬가지로 삭제연산도 dp[2][1] 값을 채우기 위함이라고 할 때 문자열 's'가 's'를 만드는 최소 연산인 dp[1][1]의 값에서 'u'를 삭제하는 연산 한번만 더해주면 원하는 값을 구할 수 있다.

교체연산의 경우 dp[2][2] 값을 채우기 위함이라고 할 때 'su'가 'sa'가 되기 위한 최소한의 연산 횟수를 구하는 것과 동일하다. 이는 's'가 's'가 되기 위한 최소한의 연산 수에서 u를 a로 교체하는 한번의 연산을 더해주면 구할 수 있으므로 dp[1][1]의 값에서 1을 더해주면 된다.

이런 관점에서 접근했을 때 점화식을 세워보면 테이블의 한 값을 구하기 위해서는 왼쪽, 위, 왼쪽 위 대각선의 값들을 비교해보고 가장 작은 값에 연산 1을 더해줘야 한다는 사실을 알 수 있다.























