---
title:  "TIL(22.01.04)"
excerpt: "Today I Learned!"

categories:
  - TIL_2022
tags:
  - TIL_2022

last_modified_at: 2022-01-04 17:00:13

toc: true
toc_label: Index
---

## Python

<br/><br/>

### 자료형의 값을 저장하는 공간, 변수

<br/>

#### 변수란?

- 파이썬에서 사용하는 변수는 객체라고도 말할 수 있다. 

  ~~~python
  >>> a = [1,2,3]
  >>> id(a)
  4303029896
  ~~~

- 위의 코드에서처럼 a=[1,2,3]이라고 선언하면 [1,2,3]을 값으로 가지는 리스트가 메모리에 자동으로 생성되고 a는 [1,2,3]리스트가 저장된 메모리 상의 주소를 가리키게 된다.

#### 변수를 만드는 여러가지 방법

  ~~~python
  # 아래 두 줄은 그 의미가 완전히 동일한 코드이다. 
  >>> a,b = ('python', 'life')
  >>> (a,b) = 'python', 'life'


  # 리스트로 변수를 만들 수도 있다.
  >>> [a,b] = ['python', 'life']


  # 여러 개의 변수에 동일한 값을 대입할 수도 있다.(두 변수가 참조하는 메모리 번지는 동일하다.)
  >>> a=b='python'


  # 파이썬에서는 두 변수의 값을 아래와 같은 방법으로 간단하게 바꿀 수 있다.
  >>> a, b = b, a
  ~~~

<br/><br/>

### 얕은 복사와 깊은 복사(shallow copy & deep copy)
#### mutable 객체와 immutable 객체
- mutable 객체 : list, set, dict
- immutable 객체 : bool, int, float, tuple, str, frozenset
- mutable한 객체인 list와 set에서 각 원소의 값에 접근하여 값을 수정하여도 변수에 처음 할당 되었던 메모리 주소 값은 변하지 않는다.

  ~~~python
  >>> a = [1, 2, 3]
  >>> id(a)
  4393788808
  >>> a[0] = 5
  >>> a
  [5, 2, 3]
  >>> id(a)
  4393788808
  ~~~

- 반면 str은 immutable객체로 처음 할당된 요소 값들을 변경할 수 없다. 변수 자체에 새로운 값을 대입하면 재할당을 하게 되는 것이며 메모리 상의 주소 또한 바뀌게 된다.

  ~~~python
  >>> s= "abc"
  >>> s
  'abc'
  >>> id(s)
  4387454680
  >>> s[0]
  'a'
  >>> s[0] = 's'
  Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  TypeError: 'str' object does not support item assignment
  >>> s = 'def'
  >>> s
  'def'
  >>> id(s)
  4388970768
  ~~~
  
<br/><br/>

#### 변수 간 대입
- mutable한 객체의 변수 간 대입
  - list의 shallow copy를 확인해 보면 b에 a를 할당했을 때 값이 할당 되는 것이 아니라 변수 a와 b가 동일한 메모리 주소를 참조하게 된다.
  - 따라서 b가 요소값을 변경하면 a도 요소값이 변경된 리스트를 참조하게 된다.
  - 이는 mutable한 객체들 사이에서 동일하게 나타난다.
    ~~~python
    >>> a = [1, 2, 3]
    >>> b = a # shallow copy
    >>> b[0]= 5
    >>> a
    [5, 2, 3]
    >>> b
    [5, 2, 3]
    >>> id(a)
    4396179528
    >>> id(b)
    4396179528
    ~~~

- immutable한 객체의 변수 간 대입
  - str문자열의 얕은 복사를 확인해보면 list때와 똑같이 b와 a는 동일한 메모리 주소를 참조하게 된다.
  - 여기에서 b에 새로운 값을 할당하게 되면 재할당이 이루어지며 b와 a는 서로 다른 메모리 주소를 참조하게 된다. 따라서 a와 b는 서로 다른 값을 가지게 된다.

    ~~~python
    >>> a = "abc"
    >>> b = a
    >>> a
    'abc'
    >>> b
    'abc'
    >>> id(a)
    4387454680
    >>> id(b)
    4387454680
    >>> b = "abcd"
    >>> a
    'abc'
    >>> b
    'abcd'
    >>> id(a)
    4387454680
    >>> id(b)
    4396456400
    ~~~

<br/><br/>

#### 얕은 복사(shallow copy)
- list의 경우 아래의 결과와 같이 슬라이싱(:)을 통해서 값을 할당하게 되면 새로운 메모리 주소가 id로 부여되며 서로 영향을 받지 않게 된다.
  
  ~~~ python
  >>> a = [1,2,3]
  >>> b = a[:]
  >>> id(a)
  4396179528
  >>> id(b)
  4393788808
  >>> a == b
  True
  >>> a is b
  False
  >>> b[0] = 5
  >>> a
  [1, 2, 3]
  >>> b
  [5, 2, 3]
  ~~~

- 하지만 이런 슬라이싱 또한 얕은 복사에 해당된다.
- 리스트 안의 리스트, mutable 객체 안에 mutable 객체가 들어가 있을 경우 문제가 되는데 이는 a와 b가 가리키는 주소 자체는 달라졌지만 리스트의 요소인 리스트의 값들은 여전히 같은 주소를 가리키고 있어서 발생하게 된다.

  ~~~ python
  >>> a = [[1,2], [3,4]]
  >>> b = a[:]
  >>> id(a)
  4395624328
  >>> id(b)
  4396179592
  >>> id(a[0])
  4396116040
  >>> id(b[0])
  4396116040


  # 값을 재할당 하는 경우에는 문제가 없다. 내부 요소값의 메모리 주소 또한 변경된다.
  >>> a[0] = [8,9]
  >>> a
  [[8, 9], [3, 4]]
  >>> b
  [[1, 2], [3, 4]]
  >>> id(a[0])
  4393788808
  >>> id(b[0])
  4396116040


  # 이 상태에서 a[1]에서 값을 변경하면 b[1]에도 값이 변경된다.
  >>> a[1].append(5)
  >>> a
  [[8, 9], [3, 4, 5]]
  >>> b
  [[1, 2], [3, 4, 5]]
  >>> id(a[1])
  4396389896
  >>> id(b[1])
  4396389896
  ~~~

- copy 모듈의 copy 메소드 또한 얕은 복사를 한다.

  ~~~python
  >>> import copy
  >>> a = [[1,2],[3,4]]
  >>> b = copy.copy(a)
  >>> a[1].append(5)
  >>> a
  [[1, 2], [3, 4, 5]]
  >>> b
  [[1, 2], [3, 4, 5]]
  ~~~

<br/><br/>

#### 깊은 복사(deep copy)
- 깊은 복사는 내부의 객체들까지 모두 새롭게 copy가 된다.
- copy.deepcopy()를 이용해 진행할 수 있다.

  ~~~ python
  >>> import copy
  >>> a = [[1,2],[3,4]]
  >>> b = copy.deepcopy(a)
  >>> a[1].append(5)
  >>> a
  [[1,2],[3,4,5]]
  >>> b
  [[1,2,],[3,4]]
  ~~~

<br/><br/><br/><br/>

---
## 레퍼런스
- [얕은 복사(shallow copy)와 깊은 복사(deep copy)](https://wikidocs.net/16038)
- [점프 투 파이썬](https://wikidocs.net/18)
























